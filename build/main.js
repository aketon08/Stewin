class i{constructor(i,t){this.x=i,this.y=t??i}}let t;var s;(s=t||(t={}))[s.Empty=0]="Empty",s[s.Floor=1]="Floor",s[s.Water=2]="Water";class o{constructor(i,t,s){this.position=i,this.direction=t,this.chanceToChange=s}}class e{tileCount=0;constructor(i,t,s,o,e){this.mapDimensions=i,this.maxWalkers=s,this.fillPercentage=o,this.waitTime=e,this.walkers=[],this.map=[],this.ctx=t}getDirection(){return Math.ceil(4*Math.random())-1}initMap(){console.log("initmap - 42");for(let i=0;i<this.mapDimensions.x;i++){this.map[i]=[];for(let s=0;s<this.mapDimensions.y;s++)this.map[i][s]=t.Empty}this.walkers.push(new o(new i(Math.floor(this.mapDimensions.x/2),Math.floor(this.mapDimensions.y/2)),this.getDirection(),.5));let s=this.walkers[0];this.map[s.position.x][s.position.y]=t.Floor,this.tileCount++,this.tick()}tick(){let i=setInterval((()=>{if(console.log("tick"),this.tileCount/(this.mapDimensions.x*this.mapDimensions.y)<this.fillPercentage){for(let i of this.walkers)this.map[i.position.x][i.position.y]==t.Empty&&(this.map[i.position.x][i.position.y]=t.Floor,this.tileCount++);this.chanceToRemove(),this.changeDirection(),this.chanceToCreate(),this.updatePosition(),this.draw(this.ctx)}else clearInterval(i)}),this.waitTime)}draw(i){console.log("draw"),i.clearRect(0,0,i.canvas.width,i.canvas.height);for(let s=0;s<this.mapDimensions.x;s++)for(let o=0;o<this.mapDimensions.y;o++)this.map[s][o]==t.Floor&&(i.fillStyle="#000",i.fillRect(i.canvas.width/this.mapDimensions.x*s,i.canvas.height/this.mapDimensions.y*o,i.canvas.width/this.mapDimensions.x,i.canvas.height/this.mapDimensions.y))}updatePosition(){console.log("updateposition");for(let i=0;i<this.walkers.length;i++){let t=this.walkers[i];switch(t.direction){case 0:t.position.y--;break;case 1:t.position.x++;break;case 2:t.position.y++;break;case 3:t.position.x--}console.log("before"+t.position.x,t.position.y),t.position.x=t.position.x>this.mapDimensions.x?0:t.position.x<0?this.mapDimensions.x:t.position.x,t.position.y=t.position.y>this.mapDimensions.y?0:t.position.y<0?this.mapDimensions.y:t.position.y,console.log("after"+t.position.x,t.position.y)}}changeDirection(){console.log("changedirection");for(let i of this.walkers)Math.random()<i.chanceToChange&&(i.direction=Math.ceil(4*Math.random())-1)}chanceToCreate(){console.log("chancetocreate");for(let t of this.walkers)if(Math.random()<t.chanceToChange&&this.walkers.length<this.maxWalkers){let s=new i(t.position.x,t.position.y),e=this.getDirection();this.walkers.push(new o(s,e,t.chanceToChange))}}chanceToRemove(){console.log("chancetoremove");for(let i of this.walkers)Math.random()<i.chanceToChange&&this.walkers.length>1&&this.walkers.splice(this.walkers.indexOf(i),1)}}const n=new i(innerHeight/6*5);new class{constructor(t){this.dimensions=t,this.canvas=document.getElementById("canvas"),this.ctx=this.canvas.getContext("2d"),this.canvas.width=this.dimensions.x,this.canvas.height=this.dimensions.y,this.map=new e(new i(10,10),this.ctx,10,.2,100)}test(){this.map.initMap()}}(n).test();